## 정의
이진 탐색(이분 탐색) 알고리즘은 **정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법**이다.
## 핵심 원리 

- 정렬된 배열에서 찾고자 하는 값과 중간값(Mid)을 비교한다. 비교 결과에 따라 탐색 범위를 왼쪽 또는 오른쪽 절반으로 줄여나간다. 이 과정은 탐색 범위가 더 이상 존재하지 않거나 목표값을 찾을 때까지 반복된다.

## 주요 특징

- **전제 조건:** 반드시 데이터가 **정렬**되어 있어야 한다.
    
- **시간 복잡도:** 매 단계마다 탐색 범위가 $1/2$씩 줄어들기 때문에 $O(\log N)$의 성능을 보이다. 이는 순차 탐색($O(N)$)에 비해 압도적으로 빠르다.
    
- **변수 설정:** 탐색의 시작점을 가리키는 `left`, 끝점을 가리키는 `right`, 그리고 그 중앙인 `mid`를 사용한다.

## 동작 방식

1. 배열의 전체 범위를 대상으로 `start`를 0, `end`를 마지막 인덱스로 설정한다.
    
2. `mid = (start + end) / 2`를 계산하여 중간값을 확인한다.
    
3. **값 비교 및 범위 이동:**
    
    - `target == mid_val`: 탐색 성공, 해당 인덱스를 반환한다.
        
    - `target < mid_val`: 찾고자 하는 값이 중간값보다 왼쪽에 있으므로 `right = mid - 1`로 범위를 좁힌다.
        
    - `target > mid_val`: 찾고자 하는 값이 중간값보다 오른쪽에 있으므로 `left = mid + 1`로 범위를 좁힌다.
        
4. `left > right`가 될 때까지 2~3단계를 반복한다.

## c++ 구현 예시

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int binarySearch(const vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2; // 오버플로우 방지 계산법

        if (arr[mid] == target) {
            return mid; // 값을 찾은 경우 인덱스 반환
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1; // 찾지 못한 경우
}
```

## 사용 사례

실제 코딩 테스트에서 가장 많이 활용되는 응용 형태이다. "특정 값이 존재하는가?"를 찾는 대신, **"조건을 만족하는 최댓값(또는 최솟값)은 무엇인가?"** 라는 최적화 문제를 결정 문제(Yes/No)로 바꾸어 해결하는 기법이다.