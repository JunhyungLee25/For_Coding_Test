# review

퇴사 전까지 남은 $N$일 동안 최대한 많은 상담 수익을 내야 하는 문제이다. 각 상담은 상담 기간($T$)과 수익($P$)이 주어지며, 상담 기간 중에는 다른 상담을 할 수 없다.
****
## 풀이 전략: Forward DP (Push 방식)
오늘 상담을 시작한다면, 해당 상담이 끝나는 **미래의 특정 날짜**에 수익을 더해주는 방식으로 풀이하였다.
****
### 코드 동작 방식
1. **수익 유지**: 이전까지의 최대 수익을 현재 날짜(`dp[i]`)에 반영합니다.
2. **범위 체크**: 상담이 퇴사일($N$) 이내에 끝나는지 확인합니다.
3. **수익 전달**: 상담 종료일 주머니(`dp[i + T[i]]`)에 현재까지 수익 + 상담 수익을 업데이트한다.
4. **최종 정산**: 퇴사 당일(`i = N`)까지 루프를 돌려 마지막 날 끝나는 수익까지 모두 확인한다.
---
## 내가 실수한 부분들

1. **퇴사일($N$)의 의미:**
    - **오해:** $N$일이 마지막 근무일이니 $N-1$까지만 계산하면 된다고 생각하였다.
    - **사실:** $N$은 근무를 마치고 짐을 싸서 나가는 **퇴사 시점**이다. $N$일차에 시작한 상담이 1일 걸린다면, 그 돈은 $N+1$일에 들어오기 때문에 퇴사 시점을 정확히 인덱싱해야 한다.
    - **놓친 점:** `i < n`으로 설정하면 마지막 날($N$일차)에 상담이 끝나서 들어오는 수입을 최종 결과(`result`)에 반영하지 못하고 정산을 끝내버리게 된다.
2. **수익의 전이 (Inheritance):**
    - **실수하기 쉬운 부분:** 특정 날짜에 상담이 없더라도, **그 전날까지 벌어둔 최대 금액**은 유지되어야 합니다. `dp[i] = max(result, dp[i])` 코드가 없으면 중간에 수익이 끊겨 보일 수 있다는 점을 배웠다.
****
## 최종 코드

```c++
#include<iostream>
#include<algorithm>

using namespace std;

int day[15];   // 상담 소요 기간 (Ti)
int wage[15];  // 상담 수익 (Pi)
int dp[16];    // i번째 날에 가질 수 있는 최대 수익

int main(void){
    ios_base :: sync_with_stdio(false);
    cin.tie(NULL);

    int n, result = 0;
    cin >> n;

    for(int i = 0; i < n; i++){
        cin >> day[i] >> wage[i];
    }

    // i <= n 까지 돌리는 이유는 n일에 딱 맞춰 끝나는 상담 수익을 반영하기 위함
    for(int i = 0; i <= n; i++){
        // 1. 현재까지의 최대 수익을 갱신
        dp[i] = max(result, dp[i]);

        // 2. 오늘 상담을 할 수 있는 경우 (퇴사 전 완료)
        if(i + day[i] <= n){
            // 상담이 끝나는 날의 dp값을 갱신 (기존 값 vs 현재까지 수익 + 상담 수익)
            dp[i + day[i]] = max(dp[i + day[i]], dp[i] + wage[i]);
        }

        // 3. 전체 최대 수익 기록
        result = max(result, dp[i]);
    }

    cout << result;
    return 0;
}
```