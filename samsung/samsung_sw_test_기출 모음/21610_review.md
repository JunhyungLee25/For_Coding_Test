## 1. 문제 분석 (Problem Analysis)

이 문제는 **격자 기반의 시뮬레이션**으로, 정해진 순서(Step)를 정확하게 구현하는 것이 핵심입니다.

- **격자의 특징**: $N \times N$ 크기이며, 1번 행/열과 $N$번 행/열이 연결된 **토러스(Torus) 구조**입니다. (경계 처리가 중요!)
    
- **핵심 로직 (5단계)**:
    
    1. 모든 구름이 지정된 방향 $d$로 $s$만큼 이동.
        
    2. 이동한 칸의 물 양 1 증가.
        
    3. 이동한 구름이 모두 사라짐.
        
    4. 물이 증가한 칸에 '물복사버그' 마법 시전 (대각선 방향 체크).
	    격자 밖은 거리 1칸으로 안침.
        
    5. 물의 양이 2 이상인 칸에 새로운 구름 생성 (단, 3단계에서 사라진 위치 제외).
        

---

## 2. 배운 점 

- **2차원 배열 좌표계의 이해**: `dy,dx` 배열을 여러번 확인했는데도 방향이 반대로 된 걸 쉽게 알아차리지 못했다. 방향을 배열을 통해 이동하는 것은 많이 나오기 때문에 다음에는 실수하지 말자.
    
- **경계값 처리 (Circular Grid)**: 인덱스가 범위를 벗어날 때(음수 혹은 $N$ 이상), 나머지 연산($\%$)을 활용하여 연결된 위치를 찾는 공식을 익혔다.
    
    - 공식: $new\_pos = (curr\_pos + (speed \times dir) \pmod N + N) \pmod N$
        
- **상태 관리의 중요성**: 구름이 '이미 이동했는지' 혹은 '이번 라운드에 사라졌는지'를 별도의 체크 배열(`inc_wt`)이나 컨테이너로 관리하여 데이터 오염을 막는 것이 중요하다.
    

---

## 3. 최종 코드 및 동작 방식 정리

문제 풀기 전에 문제에서 주어진 동작 방식을 나만의 언어로 알기 쉽게 주석으로 적어두고 필요한 변수나 배열에는 어떤것이 있을지 생각하고 들어간 것이 빠르게 문제를 풀 수 있던 주요한 이유인 것 같다. 

```c++
#include<iostream>
using namespace std;
int dy[8] = {0,-1,-1,-1,0,1,1,1};
int dx[8] = {-1,-1,0,1,1,1,0,-1};
int map[100][100];
int cloud[100][100];
int main(void){
    // 영역 입력
    // 방향, 크기 입력
    // 1. (N,1), (N,2), (N-1,1), (N-1,2)에 존재하는 구름을 d_i방향으로 s_i만큼 이동
    // M번 루프
    /*
    2. 도착칸에 물++
    3. 각 칸마다 루프 4번 돌려서 대각선의 좌표값이 둘 다 N보다 작고 물바구니에 물이 있으면 중심좌표 물바구니에 그만큼 물 더함
    4. 구름은 사라지고 그 위치 구름 사라진거 기억해둠.
    5. 전체 루프 돌면서 물바구니>=2이면 구름이 생성되고 -2
    6. 1번부터 반복
    */
    int n,m;
    int tot_wt=0;
    cin >> n >> m;
    for(int i=0; i<n; i++){
        for(int j=0; j<n; j++){
            cin >> map[i][j];
        }
    }
    cloud[n-1][0]=1;
    cloud[n-1][1]=1;
    cloud[n-2][0]=1;
    cloud[n-2][1]=1;
    while(m--){
        int inc_wt[100][100]={0};
        int d,s;
        cin >> d >> s;
        // 1. 구름을 d_i방향으로 s_i만큼 이동 + 물 증가 + 구름 삭제
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                if(cloud[i][j]==1){
                    int y_c = (i+(s*dy[d-1]%n)+n)%n;
                    int x_c = (j+(s*dx[d-1]%n)+n)%n;
                    cloud[i][j]=0; // 기존 구름이 이동함.
                    inc_wt[y_c][x_c]=1; // 물 증가 칸 마킹.
                    map[y_c][x_c]++; // 물 증가
                }
            }
        }
        // 2. 각 칸마다 루프 4번 돌려서 대각선의 좌표값이 둘 다 N보다 작고 그 칸에 물이 있으면 중심좌표(r,c)에 그만큼 물 더함
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                if(inc_wt[i][j]==1){
                    int fd_wt_cnt=0;
                    for(int k=1; k<=4; k++){
                        int y_fd_wt = i+dy[k*2-1];
                        int x_fd_wt = j+dx[k*2-1];
                        if((0<=y_fd_wt && y_fd_wt<n) && (0<=x_fd_wt && x_fd_wt<n) && map[y_fd_wt][x_fd_wt]>=1){
                            fd_wt_cnt++;
                        }
                    }
                    map[i][j] += fd_wt_cnt;
                }
            }
        }
        // 3. 전체 루프 돌면서 (구름 아니였음 && 물바구니>=2)이면 구름이 생성되고 -2
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                if(inc_wt[i][j]!=1 && map[i][j]>=2){
                    map[i][j] -= 2;
                    cloud[i][j]=1;
                }
            }
        }
    }
    for(int i=0; i<n; i++){
        for(int j=0; j<n; j++){
            tot_wt += map[i][j];
        }
    }
    cout << tot_wt;
    return 0;
}
```