## 1. 문제 개요

컨베이어 벨트 위에서 로봇을 옮기며 특정 조건(내구도가 0인 칸의 개수가 $K$개 이상)이 만족될 때까지 몇 단계가 진행되는지 계산하는 **시뮬레이션** 문제이다.

- 벨트 크기: $2N$ (윗면 $N$개, 아랫면 $N$개)
    
- 로봇 위치: 1번 칸(올리는 위치)에서 올라가서 $N$번 칸(내리는 위치)에서 즉시 내림.
    
- 종료 조건: 내구도가 0인 칸의 개수가 $K$개 이상일 때.
    

---

## 2. 핵심 설계: 구조체(Struct) 활용의 논리적 근거

벨트의 각 칸은 **내구도**와 **로봇 유무**라는 두 가지 서로 다른 데이터를 가진다.

- **데이터 응집도 향상:** 두 정보를 `con` 구조체로 묶음으로써, 벨트가 회전하거나 로봇이 이동할 때 데이터 쌍이 깨지지 않고 한꺼번에 관리되도록 설계하였다.
    
- **동기화 오류 방지:** 배열 2개를 따로 관리할 경우 발생할 수 있는 인덱스 참조 실수를 방지하고 코드의 가독성을 높였다.
    

```c++
struct con {
    int dur;  // 내구도
    int robo; // 로봇 존재 여부 (1: 있음, 0: 없음)
};
```

---

## 3. 오답 분석 및 디버깅 기록 (Trial & Error)

초기 코드에서 발생했던 논리적 오류와 이를 해결한 과정.

|**문제 현상**|**원인 분석**|**해결 방안**|
|---|---|---|
|**무한 루프 발생**|종료 조건 `if (k == 0)`이 너무 엄격함. 한 단계에서 `k`가 여러 번 감소하여 음수가 되면 조건을 건너뛰게 됨.|`if (k <= 0)`으로 변경하여 방어적인 종료 조건 설정.|
|**로봇 증식 현상**|로봇을 다음 칸으로 옮길 때, 기존 칸의 상태를 0으로 초기화하지 않아 로봇이 복제됨.|로봇 이동 후 `belt[i].robo = 0` 처리를 추가하여 로봇의 '이동'을 명확히 구현.|
|**내리는 위치 오류**|로봇이 $N$번 칸(인덱스 $N-1$)에 도달했을 때 즉시 내려야 하는 규칙을 간과함.|벨트 회전 직후와 로봇 이동 직후, 항상 $N-1$ 위치의 로봇을 제거하는 로직 보완.|

---

## 4. 최종 알고리즘 동작 방식

1. **Step 1 (벨트 및 로봇 회전):** 벨트 전체가 한 칸 회전한다. 이때 벨트 위의 로봇도 함께 이동하며, 내리는 위치에 도달한 로봇은 즉시 제거한다.
    
2. **Step 2 (로봇의 자가 이동):** 가장 먼저 벨트에 올라간 로봇부터 다음 칸으로 이동을 시도한다. (조건: 다음 칸 내구도 $\ge 1$, 다음 칸에 로봇 없음). 이동 시 내구도를 1 감소시킨다.
    
3. **Step 3 (로봇 올리기):** 올리는 위치(인덱스 0)의 내구도가 0이 아니라면 새 로봇을 올리고 내구도를 1 감소시킨다.
    
4. **Step 4 (종료 조건 확인):** 내구도가 0인 칸의 개수가 $K$개 이상인지 확인한다. (코드에서는 `k`를 직접 감소시키며 0 이하가 되는지 체크).
    

---

## 5. 최종 코드 (C++)

```c++
#include <iostream>
#include <vector>

using namespace std;

struct con {
    int dur;
    int robo;
};

int main(void) {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, k;
    cin >> n >> k;
    int step = 0;
    vector<con> belt(2 * n);

    for (int i = 0; i < n * 2; i++) {
        cin >> belt[i].dur;
        belt[i].robo = 0;
    }

    while (1) {
        step++;

        // Step 1: 회전
        int dur_temp = belt[2 * n - 1].dur;
        for (int i = 2 * n - 1; i > 0; i--) {
            belt[i] = belt[i - 1]; // 구조체 통째로 이동 (내구도 + 로봇)
        }
        belt[0].dur = dur_temp;
        belt[0].robo = 0; // 새로 들어온 칸은 로봇이 없음
        if (belt[n - 1].robo == 1) belt[n - 1].robo = 0; // 내리는 위치 로봇 제거

        // Step 2: 로봇 이동
        for (int i = n - 2; i >= 0; i--) {
            if (belt[i].robo == 1 && belt[i + 1].robo == 0 && belt[i + 1].dur >= 1) {
                belt[i + 1].robo = 1;
                belt[i].robo = 0;
                belt[i + 1].dur--;
                if (belt[i + 1].dur == 0) k--;
            }
        }
        if (belt[n - 1].robo == 1) belt[n - 1].robo = 0; // 이동 후 내리는 위치 체크

        // Step 3: 로봇 올리기
        if (belt[0].dur > 0) {
            belt[0].robo = 1;
            belt[0].dur--;
            if (belt[0].dur == 0) k--;
        }

        // Step 4: 종료 조건
        if (k <= 0) break;
    }

    cout << step;
    return 0;
}
```